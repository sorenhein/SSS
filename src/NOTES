2011-11-30

9/1232, AKT9 / Q8
The problem seems to be that it has two solutions, both with 4 tricks:
KQ or T.  The latter is not a real solution, but it arises because not
all plays are considered.

Then 9/1288, AKT7 / Q6 is supposedly the minimal version and it only
has one strategy (KQ).  It still has 6 distributions like 9/1232.

But it too has a minimal one, 9/1432, AK87 / Q6, with 4 distributions.

9/1232: 4N'S or 2N (spurious), 6 distributions
9/1288: 5N'S
9/1432: 3N'S

If we had the maximal rank of any strategy winner M (and minimum m),
then we could also tell what the minimum rank is that we should
consider for 9/1232.

M_orig = 4, m_orig = 2
M_min = 3, m_min = 3
m_orig_corrected = M_orig + m_min - M_min


So we should be able in principle to do a similar translation from
minimal to canonical as in CombTest::checkReductions. Our canonical
combination could have a maximum rank among NS of M and a minimum
rank among NS (that takes tricks) of m.  The minimal combination
might have Mc, mc.  We should have M-m = Mc-mc, M > Mc.

const auto reduction = distribution.getReduction(
  m = M - Mc + mc);  // rankAdder = M - Mc = m - m ?!

Then

strategies.expand(reduction, rankAdder, min.rotateFlag);

We also need to limit our own strategies to those strategy's that
have a winner >= m_orig_corrected.

So in CombTest::checkReductions::

bool CombTest::getMinimalRange(centries, uniqs, centry, &range)
{
  first = true
  Loop over centry.minimals
    Look up &s = uniqs[ceMin.canonical.index].strategies();
    result lowest, highest -> range
    if (first)
      range = delta
    else if (!= range)
      return false
    else
      range is still OK
  end loop
  return true
}

if (! getMinimalRange)
  assert(don't know what to do)

resultCritical = resultHighest - range
Get the reduction for this

Loop over centry.minimals
  rank adder
  expand
  compare primary tricks
  



2021-10-25

CombTest,checkReductions: Should now not need reduceByTricks.
Just use strategies.



Why doesn't minimal lookup and substitution work?
I think it's because, say, 4/62 has 6 distributions and
4/78 has 3.  So aren't there some distribution survivors
that need to be mapped as well?

Distribution.cpp has a distCanonical.
But if the combination gets rerouted to a minimal one, then
the distribution (and survivors) must be, too.
Distribution::setPtr gets called from Distributions::runUniques
and runUniqueThread.
This is based on Distribution::getID which makes the canonical
distribution with no reference to anything else.
"Canonical" means something else for Distribution than for Combination.

Actually the survivors can't be easily mapped: They're a lookup from
cards played to a distribution map.  I guess we could map twice:
First from minimal to canonical, then from canonical to parent.
But even the map from minimal to non-minimal takes us back to 
Strategies::expand, as in CombTest::checkReductions.

But at the time when we're optimizing, we look up the combination ptr.
Survivors have to be right at that point. The knowledge needed to
expand from minimal to non-minimal must then be present in the
combination somehow?  In order to get the reduction, we need
the distribution. Probably also the rank of the lowest result in
each strategies.  And the rotation from minimal to non-minimal.

The combination ptr should perhaps be an index into the overall
list of combinations.  It's a bit less efficient to look up the
combination via the unique index.  But then we have most of the tools.
We have to be able to ask Combinations.


Was 22,797 OK, 5,324 bad
Is  25,210 OK, 2,911 bad
Is  28,099 OK,    22 bad

11/133100, KJ7 / 98 miss AQT8xx and 133106, KJ7 / 95    2
-> 133108, KJ7 / 94

11/133142, KJ6 / 95 miss AQT874                         1
-> 133144, KJ6 / 94

11/133208, KJ8 / 76, 133214, KJ8 / 75                   5       plays??
   133216, KJ8 / 74, 133232, KJ8 / 65
   133234, KJ8 / 64
-> 133240, KJ8 / 54

11/133292, KJ5 / 87, 133296, KJ4 / 87                   4
   133304, KJ6 / 85, 133314, KJ4 / 86
-> 133318, KJ5 / 84

11/136124, KT8 / 76, 133130, KT8 / 75                   5       plays??
   136132, KT8 / 74, 136148, KT8 / 65
   136150, KT8 / 64
-> 136156, KT8 / 54

11/162368, QT8 / 65, 162374, QT8 / 75                   5       plays??
   162376, QT8 / 74, 162392, QT8 / 65
   162394, QT8 / 64
-> 162400, QT8 / 54


 
2. equalByMethod
   Divide completely by size
   assert size(v1) >= size(v2)?

3. Does group-trick check even work?

4. Sum of min ranks == parent rank?

5. merge...


Open issues 2021-09-26
----------------------
1. Cannot really construct the distribution mapping purely sequentially.
6/560 to 6/564
d1, d2 are the same (OK)
d4, d6 are also the same (not consecutive)
d5, d7 too.
Symmetrize also the middle distributions.

2. minimals should not prune maps to same holding3 with different
rotations.  It happens that 2N,2S maps to the same, so we'd only get
2N and not 2S in that case.



This also tests expand, constantTricksByReduction etc.

Look at speeding up Slist::equalByMethod.


3. Winners of each minimal should be the winner it was made from.
   Maybe once it has been expanded, it is easier to compare.

4. Reduce each non-minimal strategy.
   Scale up each of the minimals, including rank maps.
   Each should agree on the tricks.

5. bool Strategy::mergeComplete(const Strategy&)
   Should have same tricks throughout
   Ranks should all be the same, except that one strategy can
   consistently have one constant rank (say 4N) and the other can
   consistently have another constant rank (say 4S), and this would
   merge and return true into 4N,4S
   If #1 is true, then this can be done directly without expansion.

   If there are several minimals, 
   a. They should scale up in a way that lets them merge one by one(?)
   b. That merge should be the original strategy(?)

6. For void starting with 10-13 cards (assuming we solve up to 13
   cards), it's always OK to symmetrize.  We do this:
   a. If we get above [100] strategies, we start over and only
      look up symmetrized strategies (so 6-8 and 8-6 are done together
      and symmetrized against each other).  Multiply strategy by
      strategy, I think, and don't do a complete cross
   b. In the end, if we are above [16] strategies, we symmetrize
   c. If we know from lookup that something must be symmetric

7. Go from only batch to solving a single distribution from scratch
   a. Basic idea is to make a list of the nodes you'll need
   b. Then make these recursively before you solve this node
   c. A lot of flags are the same, i.e. ranks or not, optimizations
      turned on or not, debugging/checks on/off
   d. Could switch to the minimal one (or one of them) and only
      solve this


1091 combinations generate a "check all minimals" error.
This should hopefully be fixed once the ranks are correct.

A histogram of #strategies shows that we also get large numbers
when South has a single card, e.g. 11/132887, KJ95 / 7 missing AQT864.
Maybe it's OK to limit next strategies to symmetric ones, too,
when South becomes void and there are a lot of next strategies.

Symmetrize 11 / 132902, KJ96 / void: From 132,902 to 166 strategies.
Less than half the square root.


Reduction
---------
In Combinations, in runUniques after we have ! minimalFlag:
if some control flag:
  
  bool firstFlag = true
  Strategies strategiesExpanded;

  for each minimal in minimals:
    figure out the critical rank (store it in CombEntry, too);
    const auto& reduction = 
      distributions[centry.holding2].getReductions(fullRank);

    // Collapse distributions below the last NS rank that counts.
    // Remove ranks and Consolidate.
    Strategies strategiesOwn = comb.strategies();
    strategiesOwn.collapseDistAndRanks(reduction);

    // Remove ranks and consolidate.
    Strategies strategiesMinimal = centries[minimal.holding3];
    strategiesMinimal.collapseRanks();

    // They should now be the same.
    assert(strategiesOwn == strategiesMinimal);


    // Check that all expansions of minimal strategies are the same.
    strategiesMinimal.expand(reduction);

    if (firstFlag)
    {
      strategiesExpanded = strategiesMinimal;
      firstFlag = false;
    }
    else
    {
      assert(strategiesExpanded == strategiesMinimal);
    }

  if there are multiple winners
    // Calculate a number of total tops for each winner.
    // 4N" is 3, 4N' is 2, 4NS is 2 etc.
    // Should be the same for all winners.
    // Also, there shouldn't be any winner missing.
    // Not sure this is right, but start by saying that each side
    // has a number of tops, so all combinations of the total should
    // just be present.


* 9: 14762 (KJ97 missing 5 cards) needs 68 distributions

-d
  - Optimize the code for minimal()
  - Also optimize for Strategies == even though it doesn't matter
    - Start at ==, only do upper triangle of matrix


Checks
------
* Node optimization (on/off)
* Strategies *= optimization (on/off)

Check speed and identity of results


Ranks stored in tables
----------------------
* Write and read binary files with holdings to run vs. not
* Is it true that a minimal combination does not need non-minimal
  ones to solve?  If not, we would either solve the non-minimal
  ones, or look up the non-minimal one (probably better) and
  map the smaller number of distributions to the current case somehow


Limited Plays considered
------------------------
* Shift something in Plays or Ranks such that the card number
  starts from 1, not 0, so is distinguishable in Nodes from void
  - I think this involves switching to fullFlag in Play.h, and then
  - samePartial will make different comparisons, but
  - then void == 0 and lowest == 1, otherwise we get aliasing

* Divide Ranks optimizations into those that always make sense, and
  those that only make sense when we don't care about winners.
* Can maybe parametrize Player by full/rank-only loop.  Only needed
  for North and South.
* Can maybe parametrize the Ranks optimizations in the same way.

Make a version of Ranks::setPlays with fewer optimizations:
- Don't have to save partner's cards of equal rank
- When equal rank, all depth combinations

Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

* Actual optimizations that are probably missing today
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).


Rank issues due to limited Plays considered
-------------------------------------------
*  8 /  1585, AQ8 / JT7 missing K9.  See spreadsheet.
*  9 /  4757, AQ8 / JT7.  See spreadsheet.
* 11 / 18752, AK8 / T765.  The result is 2S" (the 5) -- not needed.


Winning NS plays in semantic form
---------------------------------
* Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
* Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy


Applying constraints to defensive holdings
------------------------------------------
* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values


Bug / behavior?
---------------
Why doesn't it work in Combination to make complete copies of
everything?  It must be some stray pointers, but where?

Mixed strategies
----------------
In the end we may not have to do so much LP.  EW must find play for
each distribution that work against all NS strategies.  EW get into
trouble when they need to vary their play depending on what NS do.
So we keep track of all plays that work in various situations, and we
take the intersection which is often not empty.

I'm hoping this will also give rise to the mandatory falsecards that
protect not this holding, but some other holding.

Perhaps represent all the NS strategies as some kind of tree with the
branching points that they will actually make use of.

In the end there will be the combinations with mixed potential.  But
I think we can do all the above independent of external constraints.
So we can actually tell in the abstract which combinations have the
potential for mixed strategies, even without knowing the constraints?!


TODO
----
Not all features of Control.cpp are implemented yet

No / limited endl

