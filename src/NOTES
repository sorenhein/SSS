- Don't really need canonical2comb
- Do need for each play a map from new rank to old one

  AJ
      Q, T
  K

  When play K - J T, want to map A -> A, K -> Q so 2 -> 5, 1 -> 3
  How to do efficiently? Just keep track of old ranks that are disappearing? How?
  But we don't need card *names* ever here?

- Move canonical to the new way of doing it
- Remove full2reduced vectors after this fix
- Put the fullCount vectors inside the north/south/opps structs?
- Better name than RankInfo3, maybe FullRankInfo
- Get rid of Ranks.cpp
- Get rid of RankInfo
- Rename RankInfo to ReducedRankInfo
- RankInfo goes inside Ranks2.cpp
- dominates() can take PositionInfo's as arguments
- play output should use full ranks as characters
  EW are named HH, hh, ...
  x's only from 9 on down, so may not be used at all
- Rename CONVERT_NORTH to POSITION_NORTH etc.


Optimizations
- If LHO void, RHO is more restricted
- If opps play Q and we have KJ (so 1 rank in between), always prefer K to J.

- canonical: 
  - c2c looks wrong?



* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values

* CombEntry -> Combination?
* Add rank = 0 for void, shift the others up
* In Combination, generate all tricks
  - First naively
  - Then properly
  - Count the difference
  - side, card1..4
  - End up with new comb, new dist bit vector
  - Also, some dist's are impossible because E or W known to be void
  - And some because of HCP or other limitations
  - Set up the tree
  - Have a dist vector that corresponds to next-level dists
  - Know which ones are possible
  - Know which cards correspond to next-level cards (and ranks)



