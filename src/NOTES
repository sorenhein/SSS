Speed:
- With only limited output, ~ 40 seconds
  -  1 sec Distributions, Ranks
  -  5 sec Plays
  - 34 sec Strategize

Strategies:
Check study and scrutinize (where are they turned on?)
- Can we avoid the scrutinize in Node?
- Then scrutinize could be private (Extension a friend, too)?
Check that comparisons are "minimal"
Introduce a flag for comparing winners or not
- Input flag
Write a perl script to process and line up outputs (sometimes
  fewer strategies, but always the same #trick profiles)
Node index: print is irritating for the early plays.
Output for e.g. 11 cards all in one hand: More space.
Output also the rank in a rank listing of cards.
Winner.cpp: Go more elegantly / faster by rank not set? Don't have
to test for mode, can just compare rank?

Speed
-----
Plays now take 26 sec: Why?
Strategize has of course become slower (44 sec).
Let's clean up the code before we optimize it.

Winner comparison: Maybe max unsigned as void?  Then simpler
comparisons.

Checks
------
* Range optimization in Nodes (on/off)
* Strategies *= optimization (on/off)
* No Strategies not minimal(), ordered()
* When a Strategies can be simplified to others due to rank,
  somehow check that those strategies that only rely on ranks
  >= the minimum ones have exactly the same Strategies, incl. ranks

Strategies += Strategies by rank comparison
-------------------------------------------
* Clean up Strategies code/directory again, especially the numbers
  and types of comparison methods
* Also optimize for speed again.  If we only need an ==, a compare
  is perhaps not needed, etc.
* When we know equality for tricks, we only need equality for ranks


Ranks stored in tables
----------------------
* Write and read binary files with holdings to run vs. not
* Is it true that a minimal combination does not need non-minimal
  ones to solve?  If not, we would either solve the non-minimal
  ones, or look up the non-minimal one (probably better) and
  map the smaller number of distributions to the current case somehow


Overall rank of a Combination
-----------------------------
* Some best winners have choices ("top 2 of 3")
  - Leave all cards that may win at declarer's choice, even though
    that combination could simplify to several others
* All unused cards can be set to x in order to get the base case
* Could validate by limiting strategies to those that don't
  distinguish by x.  But how to detect?  Maybe once we know the
  plays that go with each strategy


Limited Plays considered
------------------------
* Shift something in Plays or Ranks such that the card number
  starts from 1, not 0, so is distinguishable in Nodes from void
  - I think this involves switching to fullFlag in Play.h, and then
  - samePartial will make different comparisons, but
  - then void == 0 and lowest == 1, otherwise we get aliasing

* Divide Ranks optimizations into those that always make sense, and
  those that only make sense when we don't care about winners.
* Can maybe parametrize Player by full/rank-only loop.  Only needed
  for North and South.
* Can maybe parametrize the Ranks optimizations in the same way.

Make a version of Ranks::setPlays with fewer optimizations:
- Don't have to save partner's cards of equal rank
- When equal rank, all depth combinations

Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

* Actual optimizations that are probably missing today
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).


Rank issues due to limited Plays considered
-------------------------------------------
*  8 /  1585, AQ8 / JT7 missing K9.  See spreadsheet.
*  9 /  4757, AQ8 / JT7.  See spreadsheet.
* 11 / 18752, AK8 / T765.  The result is 2S" (the 5) -- not needed.


Only symmetric strategies with complex voids?
---------------------------------------------
* 9: 14762 (KJ97 missing 5 cards) needs 68 distributions


Winning NS plays in semantic form
---------------------------------
* Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
* Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy


Applying constraints to defensive holdings
------------------------------------------
* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values


Bug / behavior?
---------------
Why doesn't it work in Combination to make complete copies of
everything?  It must be some stray pointers, but where?


TODO
----
