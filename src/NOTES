2021-05-23
----------
Ideas for speeding up Strategies

Make things like Result smaller (char might be enough for dist and tricks)

Strategies:multiplyAdd, i.e. Strategy::multiply
- Find the overlapping distributions
- Find the strat1-only distributions and their cross matrix
- Find the strat2-only distributions and their cross matrix
- When multiplying, only multiply the overlapping ones and note
  the index of the non-overlapping regions
- When comparing two of them, first examine the non-overlapping
  results (>, =, <, !=)


s1 | s2   >             =               <               !=
>         >, !=         >, !=           just !=         just !=
=         >, !=         any             <, !=           just !=      
<         just !=       <, !=           <, !=           just !=
!=        just !=       just !=         just !=         just !=

- So in 9 of 16 cases we already know the result, and we just have
  to find the right weight at which to insert (which could also be
  a lookup...)
- We also have the weight as an indicator >, =, <
- In the other 7, we have to compare the overlapping bits as well
- In any case, in the end, we have to multiply the non-overlaps
  only each strategy (and study it)

scrutinize()
- Instead of consecutive groups of 5, find a stride.
  numGroups or stride = (results.size() / 5) + 1
  profiles is a vector<unsigned>
- counter % stride is the profiles index



2021-05-09
----------
10 / 41388: 9 - 8 - void - J: getStrategies are not in descending
weight order, probably because we threw away some strategies!
Does this matter, or is it fixed when we multiply stategies anyway?

Time strategize with and without constant and domination removals.
- In the first instance for RHO / pard
  - Maybe also for LHO / lead
  - There may be a wonky way to += Strategy vectors without first
    collapsing the constants.  Is it worth it?

Completely global constant results: Separate out, too?

Why doesn't it work in Combination to make complete copies of
everything?  It must be some stray pointers, but where?

When we don't solve all Combination's because of ranks, we have
to spread out the more concentrated distributions onto the current
trick if needed.


2021-04-28
----------
- Ranks
  - number to start from 1 when non-void, not 0
  - Check that number (not rank) is used appropriately

2021-04-26
----------

Tvectors etc.:
- Check rank vs number used appropriately (I think it isn't)

Player:
- Streamline the Player post-processing into a single call. (done?)
- Streamline Player variables and name them temp loop variables. (done?)

Errors:
- 4 cards / 8, AK / - (missing HH): The printed ranks in Play #2 are odd.
- Sometimes no ranks at all, e.g. the 9-card void combination.

Divide Ranks optimizations into those that always make sense, and
those that only make sense when we don't care about winners.

Can maybe parametrize Player by full/rank-only loop.  Only needed
for North and South.

Can maybe parametrize the Ranks optimizations in the same way.



March 2021
----------
KQ / J9 missing AT: EW can make NS choose between K (duck) and QJ (win).
QJ / K9: Same, here it's Q and KJ.
KJ / Q9: K or JQ.
It seems true that not just the K should be the winner in the end.
In a way, the problem is that that we could simplify to KQ / xx or
to Kx / Qx. In fact, here probably it's an EW choice between K and Q.
And these should definitely both survive.

So in these three cases more generally, the first trick can go
N1 wins, then no more tricks for NS.
It can also go
N1 loses, then NS just have a choice between N2 and S1.
N1 * (N2 + S1) = N2 + N1*S1.
This means we can either view it as KQ / xx or as Kx / Qx.

2021-03-21
----------
Make a version of Ranks::setPlays with fewer optimizations:
- Don't have to save partner's cards of equal rank
- When equal rank, all depth combinations

Issues
1. 10/4025, AK76 / QT9 missing J85:
   a. 7 5 T 8 has T as winner!  (Play 4)
   b. T - A 5 segfaults, probably because it's a rotation

2. Drilling down from this, if the first trick goes 7 - T J,
   it leaves us with 7/128 so AK9 / QJ missing T8.  Because of 
   optimizations in Ranks.cpp, we don't get to see all the combinations
   of ranks that can happen.  So if it goes Q - 9 8, we have
   SQ * (NA + SJ) = NA*SQ + SJ = NA*SQ,
   as we'd always prefer the choice between NA and SQ to a forced SJ.
   This of course assumes that we win with the SQ and not the SJ in 
   the first trick.

3. It could also have gone e.g. Q T A 8 which is a choice NA + SQ.
   This is better (more flexible) for NS than just SQ which is the
   current outcome when d = 2.

4. It could also go A - Q 8, so
   (NA + SQ) * (NK + SJ) = NK + SJ + NK*SQ + NA*SJ = NK + SJ, 
   as NK*SQ is worse for NS than just NK.

5. But it could also go A - J 8, so
   (NA + SJ) * (NK + SQ) = NK + SJ + NA*SQ + NK*SJ = NK + SJ + NA*SQ,
   which makes sense.  We can reduce to AKx / xx, xx / AKx or Axx / Kx.

6. Or it could go K - Q 8(?), so
   (NK + SQ) * (NA + SJ) = NK + SJ + NA*SQ + NK*SJ = #5

7. Or it could go K - J 8, so
   (NK + SJ) * (NA + SQ) = NK + SJ + NA*SJ + NK*SQ = #4
   
   So how do we make sure to get the second and not the first result?

8. Another example: AKx / JT missing Qxx.
   J x x: NK*SJ.
   J Q A: NA * (NK * ST) = NK*ST.

   T x x: NK*ST.
   T Q A: NA * (NK * SJ) = NK*SJ.

   It looks as if EW can force NK*ST no matter how South starts.
   I suppose that's as it should be.  So we can always start with the
   highest rank -- it doesn't matter.

9. Problem #1 is that Ranks optimizes away plays that are relevant
   for ranks in this case.  So Ranks could have a full-play mode, needed
   to calculate the tables of relevant ranks (stored in files).  And
   a reduced-play mode as now.

10.Problem #2 is when NS have a shared winner in the current trick.
   It's not clear then which depths were played. Can we just choose
   the highest from one side and the lowest from the other? Or do we
   need to consider two such combinations? Here it would work.
   

Still need to look at += at vector level and choose among equal-trick
vectors the one with the best rank profile (can we need both?).


Rank tracking
* += is more or less unchanged, but if two vectors are equal,
  and NS can pick one, then hopefully one dominates the other
  (or they are equal) in terms of ranks.  Otherwise assert
* Tvector: add method lowestWinner()
* Tvectors: ditto
* Somehow map to the holding without lower cards than this mattering

   

Summary of speed-up considerations
----------------------------------

Rank equivalence

* 9: 14762 (KJ97 missing 5 cards) needs 68 distributions with the
  normal analysis, and still needs 58 distributions the new way
* When we lead the 7, the defenders with 4/5 cards can probably pick
  constant plays that leave declarer no recourse
* With 3 cards, the defenders can choose to yield "KJ9" or "KJT",
  no matter what the lead is (as long as they're not forced to
  play the Q or A, which again leads to no declarer choice)
* So in a sense the small cards x, 8 and T don't matter!
* We have to recognize this somehow, as strategies will merge

Play eliminations
-----------------

Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

Optimization in Ranks:
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).

- Winning ranks for NS
- Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
- Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy

------

* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values

