2022-01-04
==========

CombTest errors
---------------

WARN-NONMIN       72
ERROR           2139

MINIMUM MATCH 122981
MISMATCH        2968

Other checks not implemented yet
--------------------------------
* Ranks: If NS" and N"S, also N'S' and nothing else, etc.

* Unranked strategies should all be among ranked ones, and no
  ranked one should go away in terms of its number of tricks


Ideas against errors
--------------------

Some Strategy's implicitly do need a lower card than actually wins
a trick.  They probably arose when multiplying together Strategy's,
one of which needed the lower card.  The card itself disappeared,
but declarer had to be willing to accept that lower rank to get some
of the other results as well.  Somehow we have to keep track of this.

Each Strategy (or even each Result!) may have an explicit winner
for which it is valid.
1. Introduce and keep this Strategy-level winner updated
2. Rely on it

Examples
--------

7/1595, KT9 / Q missing AJ8
There is a second strategy starting Q J K, otherwise Q ? 9.
This leads to the same #tricks and a different rank profile,
losing against d = 2 (J / A8) and d = 4 (J8 / A) needing the T, and
winning against d = 6 (AJ / 8) needing only the K no matter what.

This has two minimals, 7/1611 K98 / Q, and 7/1599 KT8 / Q.
7/1611 only has one strategy which is the same as in 7/1595
when ducking the queen.
7/1599 also only has one strategy.  We get to the point of Q J K:
d = 2: 2, 3N
    4: 2, 3N
    6: 2, 5N
    7: 1, 5N

The problem is that for d = 7 it now costs a trick to overtake the
queen, leaving K8 missing A9.  West should never play the jack from
AJ8 as it costs a trick.  

Probably the only real solution is to compare strategies not
primary-secondary but holistically.  Do I want to make that change?
There are many other cases where this would go too far.

Or rather, shouldn't 1595 need the 9 in some variations?  Against
d = 7 (AJ8) we can only afford Q J K because we have the T 9.

--------

7/1799, AT / QJ9 missing Kxx.
#0 top
#1 run the J
#2 run the Q

7/1855, A8 / QJ7 missing KT9.
#0 top
#1 run the J
The problem with running the Q here is that they cover in d=5, leading
to 3S' (J) and not 2S (Q) as in 7/1799.  In 7/1799 it would cost 
a trick to cover, but here it doesn't, so they can force the use
of the lower rank.  Then #2 loses to #1, which it doesn't in 7/1799.

So again #2 in 7/1799 arose because there was a strategy on the
way where declarer needed 2NS' and not just 2S' for d = 5.
That makes 7/1799 a partial self-minimum.

Plays generated in Ranks
------------------------

When ranked
...........
The equivalent of one rank is a singleton card.  Probably always lead
this.

Look for other cases where we were too harsh in permitting plays.

8/1773: Leading the 7 is conceivable(?), but the 8?
Actually with the stiff queen, shouldn't we just lead it?

When unranked
.............
Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

* Actual optimizations that are probably missing today
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).


Overall partitioning
--------------------
* Has at least one reference to self -> minimal

* Can characterize solved, ranked combinations as canonical or not,
  and minimal or not (bit vector of bools?)

Symmetrization
--------------

* For void starting with 10-13 cards (assuming we solve up to 13
  cards), it's always OK to symmetrize, as we can never get there
  from non-void combinations.  We do this:
  a. If we get above [100] strategies, we start over and only
     look up symmetrized strategies (so 6-8 and 8-6 are done together
     and symmetrized against each other).  Multiply strategy by
     strategy, I think, and don't do a complete cross
  b. In the end, if we are above [16] strategies, we symmetrize
  c. If we know from lookup that something must be symmetric

* A histogram of #strategies shows that we also get large numbers
  when South has a single card, e.g. 11/132887, KJ95 / 7 missing AQT864.
  Maybe it's OK to limit next strategies to symmetric ones, too,
  when South becomes void and there are a lot of next strategies.

* Symmetrize 11 / 132902, KJ96 / void: From 132,902 to 166 strategies.
  Less than half the square root.


Optimizations
-------------
* If there is a Result per Strategy, equality can be tested first
  in this way.  And then one Result per group (Reduction).
  - One classical lowest result, one that takes history into account
  - In print output, show the result(s)

* Similarly when only < or > is possible.  Take the lowest one and
  its groups.

* Would it be worthwhile to store the minimal numbers in the Strategy
  as well?
  -- Then it would also be in the print output, in the table itself

* CombTest streamlining, esp. CombEntry (become a clasS?) and its
  storage requirement

* Maybe instead of the NS business, we just go by absNumber in Card?
  Then that is a simple comparison.  Are there cases where winners are
  not of this form?

* CombTest,checkReductions: Should now not need reduceByTricks.
  Just use strategies.

* In Card, can we think of a way to avoid depth?  Probably not, 
  as it is useful for the output.  Maybe avoid number then? Or name?

* Optimize the code for minimal().  Is it even used?

* Look at speeding up Slist::equalByMethod.
  Divide completely by size
  assert size(v1) >= size(v2)?

* Also optimize for Strategies == even though it doesn't matter
  - Start at ==, only do upper triangle of matrix

* Is Declarer::greater used?  Is it completely right?

* No / limited endl


Non-batch one-shots
-------------------

* Go from only batch to solving a single distribution from scratch
  a. Basic idea is to make a list of the nodes you'll need
  b. Then make these recursively before you solve this node
  c. A lot of flags are the same, i.e. ranks or not, optimizations
     turned on or not, debugging/checks on/off
  d. Could switch to the minimal one (or one of them) and only
     solve this

Ranks stored in tables
----------------------
* Write and read binary files with holdings to run vs. not
* Is it true that a minimal combination does not need non-minimal
  ones to solve?  If not, we would either solve the non-minimal
  ones, or look up the non-minimal one (probably better) and
  map the smaller number of distributions to the current case somehow


Mixed strategies
----------------
In the end we may not have to do so much LP.  EW must find play for
each distribution that work against all NS strategies.  EW get into
trouble when they need to vary their play depending on what NS do.
So we keep track of all plays that work in various situations, and we
take the intersection which is often not empty.

I'm hoping this will also give rise to the mandatory falsecards that
protect not this holding, but some other holding.

Perhaps represent all the NS strategies as some kind of tree with the
branching points that they will actually make use of.

In the end there will be the combinations with mixed potential.  But
I think we can do all the above independent of external constraints.
So we can actually tell in the abstract which combinations have the
potential for mixed strategies, even without knowing the constraints?!


Features
--------
* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values

* Not all features of Control.cpp are implemented yet

* Check sometime that these still work
  - Node optimization (on/off)
  - Strategies *= optimization (on/off)


Semantics, verbal descriptions
------------------------------
* Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
* Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy

* Verbal description of NS strategy
  - Minterms?


Bugs
----
Why doesn't it work in Combination to make complete copies of
everything?  It must be some stray pointers, but where?

