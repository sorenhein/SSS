Ideas for speeding up Tvector
---
- Initially just a flat list
- organize(ordered list of distributions in groups)
  makes partial sums for the groups
  also makes a kind of hash for equality checking (group sums)
- partials()
  returns ordered list of partial sums for groups
- prioritize(ordered list of groups)
  sets the order of comparison.  Top group is the one where the vector
  is relatively highest.  So if you want to beat this vector, you
  compare first to the toughest comparison in order to lose quickly.
  If you want to lose to this vector, you first try to lose to its
  weakest group in order to fail quickly
- == first uses the hash and then individually
- > uses the prioritized groups and then individually

Ideas for speeding up Tvectors
---
* Organization
  - Histogram of vector weights, each bucket containing a list
* In +=
  - First check for equality
    If it works, we're done
  - Then check whether we're dominated by something
    If yes, we're done
  - Add ourselves to the histogram
  - Then check whether we dominate something
    If yes, remove it
* In *=
  - Start with the largest times one vector
  - organize() each vector with a list, maybe co-prime "hash"
  - Figure out the partials
  - Sort them
  - prioritize() each vector
  - Then go through the other second vectors
  - After ~ 20% of the second vectors, re-sort and re-prioritize()



Does it get permanently stuck on 12 / 398582?
KJ975 / void missing AQT86xx.
It seems we stall when multiplying 906 * 540 strategies.
Or thereafter, 20k * 44 :-)

Can we run cards <= 10 and then run 11 / 132902 separately?
It has 9660 strategies.  KJ96 / void, missing AQT87xx.
The 6 does matter.

Takes several hours (3+) even to do 12 cards.  This doesn't scale.
Some combinations have absurd numbers of combinations, e.g.
KJ975 /3 missing AQT864 has 3880 strategies and 64 distributions.

Probably the *= of Tvectors from following combinations creates
a lot of combinations and comparisons.

How do we get the complexity down again?
- Some of the most complex ones have spurious ranks, so we just need
  to find them and then cut off below that ranks.  But we do need to
  solve at least once.
- The *= can be improved to do partial comparisons before full ones.
- Are there plays that can be cut out?  3-6: Never any reason to
  play 5 rather than 7.
- Even so, how can it take that long??
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.


Optimization in Ranks:
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).

Plays become more complicated when we have to keep track of:

- Winning ranks for NS
- Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
- Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy

------

* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values

