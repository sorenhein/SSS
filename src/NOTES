Distribution
------------
Maybe pre-store this, as it's likely to be quite fast
For each possible NS splitting rank, which starts above the highest
EW rank and goes down to above the lowest EW rank

Loop over distributions (DistInfo)
  If change in length, it's a new one
  If different in the ranks > the divider, it's a new one
  Otherwise it isn't
  Build up a vector<vector<unsigned char>>, perhaps
  The first index is the external, full rank that NS split on
  The second index is the full distribution number
  The value is the reduced count

// reducer is the full (external) NS rank on which we reduce.
// It makes no sense to reduce on rank 0 (void).  
// Even rank 1 would not cause any reduction.

reductionMatrix.resize(full2reduced.size() + 1);

for (unsigned reducer = 1; reducer <= full2reduced.size(); reducer++)
{
  bool firstFlag = true;
  unsigned nextReduced = 0;
  vector<unsigned>& reduction = reductionMatrix[reducer];
  reduction.resize(distributions.size());

  for (unsigned d = 0; d < distributions.size(); d++)
  {
    if (firstFlag)
    {
      reduction[d] = nextReduced++;
      firstFlag = false;
      continue;
    }

    bool changeFlag = false;
    for (rankFull: reverse from full2reduced.size() to 0, careful unsigned)
    {
      // Stop when we've run out of meaningful ranks
      if (rankFull <= reducer)
        break;

      const unsigned rankReduced = full2reduced[rankFull];
      if (distributions[d].west.counts[rankReduced] !=
          distributions[d-1].west.counts[rankReduced] ||
          distributions[d].east.counts[rankReduced] !=
          distributions[d-1].east.counts[rankReduced])
      {
        changeFlag = true;
        break;
      }
    }

    reduction[d] = nextReduced;

    if (changeFlag)
      nextReduced++;
  }
}

vector<unsigned char>& reductions(const unsigned char fullRank) const
{
  return reductionMatrix[fullRank];
}

Then in Combinations, say in runUniques after we have ! minimalFlag:
if some control flag:
  for each minimal in minimals:
    figure out the critical rank (store it in CombEntry);
    auto& reduction = distributions[centry.holding2].reductions(fullRank);

    // Remove winners, collapse distributions
    Strategies strategiesOwn = comb.strategies();
    strategiesOwn.collapse(reduction);

    Strategies strategiesMinimal = centries[minimal.holding3];
    strategiesMinimal.collapseTricks();

    assert(strategiesOwn == strategiesMinimal);


Actually we reduce, and that's one test.  We also want to be able to
expand.  And we can test that all the expansions to our holding
(only if there are several, of course) yield the same tricks and
strategies.  So there are two tests.




Use CombinationType in CombEntry
NON_CANONICAL
NON_MINIMAL
CONSTANT (includes TRIVIAL)
SIMPLE
COMPLEX
Maybe these are indices in Combinations.h into a counter
The print-out then becomes more generic, and there is a string as
a header for each block in the count output


Validate minimal strategies
- Strip the ranks
- Collapse the distributions according to some map or algorithm
- Compare strategies using == (optimize it at last?)

- symmetrize too-large void strategies that we receive


-d
  - Optimize the code for minimal()
  - Also optimize for Strategies == even though it doesn't matter
    - Start at ==, only do upper triangle of matrix


Checks
------
* Node optimization (on/off)
* Strategies *= optimization (on/off)

Check speed and identity of results


Ranks stored in tables
----------------------
* Write and read binary files with holdings to run vs. not
* Is it true that a minimal combination does not need non-minimal
  ones to solve?  If not, we would either solve the non-minimal
  ones, or look up the non-minimal one (probably better) and
  map the smaller number of distributions to the current case somehow


Overall rank of a Combination
-----------------------------
* Some best winners have choices ("top 2 of 3")
  - Leave all cards that may win at declarer's choice, even though
    that combination could simplify to several others
* All unused cards can be set to x in order to get the base case
* Could validate by limiting strategies to those that don't
  distinguish by x.  But how to detect?  Maybe once we know the
  plays that go with each strategy


Limited Plays considered
------------------------
* Shift something in Plays or Ranks such that the card number
  starts from 1, not 0, so is distinguishable in Nodes from void
  - I think this involves switching to fullFlag in Play.h, and then
  - samePartial will make different comparisons, but
  - then void == 0 and lowest == 1, otherwise we get aliasing

* Divide Ranks optimizations into those that always make sense, and
  those that only make sense when we don't care about winners.
* Can maybe parametrize Player by full/rank-only loop.  Only needed
  for North and South.
* Can maybe parametrize the Ranks optimizations in the same way.

Make a version of Ranks::setPlays with fewer optimizations:
- Don't have to save partner's cards of equal rank
- When equal rank, all depth combinations

Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

* Actual optimizations that are probably missing today
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).


Rank issues due to limited Plays considered
-------------------------------------------
*  8 /  1585, AQ8 / JT7 missing K9.  See spreadsheet.
*  9 /  4757, AQ8 / JT7.  See spreadsheet.
* 11 / 18752, AK8 / T765.  The result is 2S" (the 5) -- not needed.


Only symmetric strategies with complex voids?
---------------------------------------------
* 9: 14762 (KJ97 missing 5 cards) needs 68 distributions


Winning NS plays in semantic form
---------------------------------
* Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
* Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy


Applying constraints to defensive holdings
------------------------------------------
* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values


Bug / behavior?
---------------
Why doesn't it work in Combination to make complete copies of
everything?  It must be some stray pointers, but where?

Mixed strategies
----------------
In the end we may not have to do so much LP.  EW must find play for
each distribution that work against all NS strategies.  EW get into
trouble when they need to vary their play depending on what NS do.
So we keep track of all plays that work in various situations, and we
take the intersection which is often not empty.

I'm hoping this will also give rise to the mandatory falsecards that
protect not this holding, but some other holding.

Perhaps represent all the NS strategies as some kind of tree with the
branching points that they will actually make use of.

In the end there will be the combinations with mixed potential.  But
I think we can do all the above independent of external constraints.
So we can actually tell in the abstract which combinations have the
potential for mixed strategies, even without knowing the constraints?!


TODO
----
Not all features of Control.cpp are implemented yet
