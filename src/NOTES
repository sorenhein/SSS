Reduction
---------
In Combinations, in runUniques after we have ! minimalFlag:
if some control flag:
  
  bool firstFlag = true
  Strategies strategiesExpanded;

  for each minimal in minimals:
    figure out the critical rank (store it in CombEntry, too);
    const auto& reduction = 
      distributions[centry.holding2].getReductions(fullRank);

    // Collapse distributions below the last NS rank that counts.
    // Remove ranks and Consolidate.
    Strategies strategiesOwn = comb.strategies();
    strategiesOwn.collapseDistAndRanks(reduction);

    // Remove ranks and consolidate.
    Strategies strategiesMinimal = centries[minimal.holding3];
    strategiesMinimal.collapseRanks();

    // They should now be the same.
    assert(strategiesOwn == strategiesMinimal);


    // Check that all expansions of minimal strategies are the same.
    strategiesMinimal.expand(reduction);

    if (firstFlag)
    {
      strategiesExpanded = strategiesMinimal;
      firstFlag = false;
    }
    else
    {
      assert(strategiesExpanded == strategiesMinimal);
    }

  if there are multiple winners
    // Calculate a number of total tops for each winner.
    // 4N" is 3, 4N' is 2, 4NS is 2 etc.
    // Should be the same for all winners.
    // Also, there shouldn't be any winner missing.
    // Not sure this is right, but start by saying that each side
    // has a number of tops, so all combinations of the total should
    // just be present.


Maybe these are indices in Combinations.h into a counter
The print-out then becomes more generic, and there is a string as
a header for each block in the count output


Symmetrize too-large void strategies that we receive
for all plays
  if lho < rho
    look for the play where rho < lho
    check same holding
    adapt both to this trick
    multiply the strategies pairwise, but not the whole cross
  else if lho == rho
    nothing special
  else if lho > rho
    skip, as already processed

* 9: 14762 (KJ97 missing 5 cards) needs 68 distributions

-d
  - Optimize the code for minimal()
  - Also optimize for Strategies == even though it doesn't matter
    - Start at ==, only do upper triangle of matrix


Checks
------
* Node optimization (on/off)
* Strategies *= optimization (on/off)

Check speed and identity of results


Ranks stored in tables
----------------------
* Write and read binary files with holdings to run vs. not
* Is it true that a minimal combination does not need non-minimal
  ones to solve?  If not, we would either solve the non-minimal
  ones, or look up the non-minimal one (probably better) and
  map the smaller number of distributions to the current case somehow


Limited Plays considered
------------------------
* Shift something in Plays or Ranks such that the card number
  starts from 1, not 0, so is distinguishable in Nodes from void
  - I think this involves switching to fullFlag in Play.h, and then
  - samePartial will make different comparisons, but
  - then void == 0 and lowest == 1, otherwise we get aliasing

* Divide Ranks optimizations into those that always make sense, and
  those that only make sense when we don't care about winners.
* Can maybe parametrize Player by full/rank-only loop.  Only needed
  for North and South.
* Can maybe parametrize the Ranks optimizations in the same way.

Make a version of Ranks::setPlays with fewer optimizations:
- Don't have to save partner's cards of equal rank
- When equal rank, all depth combinations

Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

* Actual optimizations that are probably missing today
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).


Rank issues due to limited Plays considered
-------------------------------------------
*  8 /  1585, AQ8 / JT7 missing K9.  See spreadsheet.
*  9 /  4757, AQ8 / JT7.  See spreadsheet.
* 11 / 18752, AK8 / T765.  The result is 2S" (the 5) -- not needed.


Winning NS plays in semantic form
---------------------------------
* Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
* Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy


Applying constraints to defensive holdings
------------------------------------------
* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values


Bug / behavior?
---------------
Why doesn't it work in Combination to make complete copies of
everything?  It must be some stray pointers, but where?

Mixed strategies
----------------
In the end we may not have to do so much LP.  EW must find play for
each distribution that work against all NS strategies.  EW get into
trouble when they need to vary their play depending on what NS do.
So we keep track of all plays that work in various situations, and we
take the intersection which is often not empty.

I'm hoping this will also give rise to the mandatory falsecards that
protect not this holding, but some other holding.

Perhaps represent all the NS strategies as some kind of tree with the
branching points that they will actually make use of.

In the end there will be the combinations with mixed potential.  But
I think we can do all the above independent of external constraints.
So we can actually tell in the abstract which combinations have the
potential for mixed strategies, even without knowing the constraints?!


TODO
----
Not all features of Control.cpp are implemented yet

No / limited endl
