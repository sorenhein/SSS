2. adapt() must update ranks
3. += is more or less unchanged, but if two vectors are equal,
   and NS can pick one, then hopefully one dominates the other
   (or they are equal) in terms of ranks.  Otherwise assert
4. *= gives EW a choice if the number of tricks is equal.
   

Summary of speed-up considerations
----------------------------------

Rank equivalence

* 9: 14762 (KJ97 missing 5 cards) needs 68 distributions with the
  normal analysis, and still needs 58 distributions the new way
* When we lead the 7, the defenders with 4/5 cards can probably pick
  constant plays that leave declarer no recourse
* With 3 cards, the defenders can choose to yield "KJ9" or "KJT",
  no matter what the lead is (as long as they're not forced to
  play the Q or A, which again leads to no declarer choice)
* So in a sense the small cards x, 8 and T don't matter!
* We have to recognize this somehow, as strategies will merge

Similarity

* Treat K A x the same as J Q x?  They end up in the same next
  combination, with the cards from the same side.  So then merge
  using |=, not *= ?
  - Probably not a good idea

Improve *= efficiency

* If merge doesn't change the vector, no need to compare
* Short strategy, e.g. with 3 distributions
  - Somehow split into overlapping/in-band and other/out-of-band
    distributions
  - Is there a way to tell in some cases that something will be
    a surviving strategy?
* In the merged strategy, the two non-overlaps' origins in the original
  strategies are stored
  - Before merging, we study the non-overlaps
  - How many really distinct ones are there?
  - If not a lot, consider a complete cross-table (matrix) of
    relationships (dominates, is dominated by, is different)
  - Also three lists for each one of dominates, is dominated by etc.
  - Can index by the weight of the non-overlapping part?
* In a new merge, the non-overlaps are just copied over
  - We can tell by looking at other merges whether we have a chance
    or dominating or being dominated by
* The overlaps do have to be made properly
  - Can stop if the two overlaps are already "contradictory"
  - Even if we don't stop, some theories can be eliminated
  - Their weight is a first indication of possible domination
  - Then drill down into pieces
* In a merge, start looking for identities?  (Empirical question)
* Then look for being dominated?
  - The accepted strategy has a profile across buckets, and we can
    make statistics
  - We pick our own strongest bucket first and try to beat other
    stored strategies 
- Initially just a flat list
- organize(ordered list of distributions in groups)
  makes partial sums for the groups
  also makes a kind of hash for equality checking (group sums)
- partials()
  returns ordered list of partial sums for groups
- prioritize(ordered list of groups)
  sets the order of comparison.  Top group is the one where the vector
  is relatively highest.  So if you want to beat this vector, you
  compare first to the toughest comparison in order to lose quickly.
  If you want to lose to this vector, you first try to lose to its
  weakest group in order to fail quickly
- == first uses the hash and then individually
- > uses the prioritized groups and then individually
* Organization
  - Histogram of vector weights, each bucket containing a list
* In +=
  - First check for equality
    If it works, we're done
  - Then check whether we're dominated by something
    If yes, we're done
  - Add ourselves to the histogram
  - Then check whether we dominate something
    If yes, remove it
* In *=
  - Start with the largest times one vector
  - organize() each vector with a list, maybe co-prime "hash"
  - Figure out the partials
  - Sort them
  - prioritize() each vector
  - Then go through the other second vectors
  - After ~ 20% of the second vectors, re-sort and re-prioritize()
* Ordering of strategies in *= sequence?!
  - Maybe do the two "halves" and then merge to break symmetry?!
*

Speed-ups:

- Tvectors::reinstate(const Tvector& constants)
  Puts the constant distributions back.
  They must not already be there.
  Adjust weights too.

Play eliminations
-----------------

Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

Optimization in Ranks:
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).

How do we get the complexity down again?
- The *= can be improved to do partial comparisons before full ones.



- Winning ranks for NS
- Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
- Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy

------

* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values

