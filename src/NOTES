Winner::declarerPrefers can probably either become or be split into
a secondary compare that ignores tricks.  Look in Winners at all
usages.
Rename declarerPrefers to lessEqual, ...

Winner.cpp: Go more elegantly / faster by rank not set? Don't have
to test for mode, can just compare rank?

Winner comparison: Maybe max unsigned as void?  Then simpler
comparisons.


Go through all TODO's in Strategies and Slist.

In Strategies, get study, scrutinize and methods cleaned up.
Study might also be an active act, not something that Strategy
does itself.  Time it.

Check that the comparators are sensible and minimal.

StratData could be used in str()?  Its ptr could be const?
Is the ptr even used?


-r could be for run flags
- Play-level choice (void, optimized, normal)
- Range optimization or not
- Various choiced in Strategies
- Use ranks for comparisons or not (if yes, they are also in
  debug output)
- Control plays, either all plays or only optimized ones

Then we could have a script to compare outputs
- All 2^n versions
- Line counts
- Times elapsed
- Actual strategies
- If with/without rank, compare appropriately by other script

-d
- Check that comparisons are minimal
  - Optimize the code for this
  - Also optimize Strategies == even though it doesn't matter
    - Start at ==, only do upper triangle of matrix


Checks
------
* Range optimization in Nodes (on/off)
* Strategies *= optimization (on/off)
* No Strategies not minimal(), ordered()
* When a Strategies can be simplified to others due to rank,
  somehow check that those strategies that only rely on ranks
  >= the minimum ones have exactly the same Strategies, incl. ranks


Ranks stored in tables
----------------------
* Write and read binary files with holdings to run vs. not
* Is it true that a minimal combination does not need non-minimal
  ones to solve?  If not, we would either solve the non-minimal
  ones, or look up the non-minimal one (probably better) and
  map the smaller number of distributions to the current case somehow


Overall rank of a Combination
-----------------------------
* Some best winners have choices ("top 2 of 3")
  - Leave all cards that may win at declarer's choice, even though
    that combination could simplify to several others
* All unused cards can be set to x in order to get the base case
* Could validate by limiting strategies to those that don't
  distinguish by x.  But how to detect?  Maybe once we know the
  plays that go with each strategy


Limited Plays considered
------------------------
* Shift something in Plays or Ranks such that the card number
  starts from 1, not 0, so is distinguishable in Nodes from void
  - I think this involves switching to fullFlag in Play.h, and then
  - samePartial will make different comparisons, but
  - then void == 0 and lowest == 1, otherwise we get aliasing

* Divide Ranks optimizations into those that always make sense, and
  those that only make sense when we don't care about winners.
* Can maybe parametrize Player by full/rank-only loop.  Only needed
  for North and South.
* Can maybe parametrize the Ranks optimizations in the same way.

Make a version of Ranks::setPlays with fewer optimizations:
- Don't have to save partner's cards of equal rank
- When equal rank, all depth combinations

Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

* Actual optimizations that are probably missing today
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).


Rank issues due to limited Plays considered
-------------------------------------------
*  8 /  1585, AQ8 / JT7 missing K9.  See spreadsheet.
*  9 /  4757, AQ8 / JT7.  See spreadsheet.
* 11 / 18752, AK8 / T765.  The result is 2S" (the 5) -- not needed.


Only symmetric strategies with complex voids?
---------------------------------------------
* 9: 14762 (KJ97 missing 5 cards) needs 68 distributions


Winning NS plays in semantic form
---------------------------------
* Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
* Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy


Applying constraints to defensive holdings
------------------------------------------
* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values


Bug / behavior?
---------------
Why doesn't it work in Combination to make complete copies of
everything?  It must be some stray pointers, but where?


TODO
----
