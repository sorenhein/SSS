Strategies += Strategies by rank comparison
-------------------------------------------
Places where Strategy's are compared:
* Strategies::addStrategy [implemented rank equality here only for now]
* Strategies::multiplyAddStrategy
* Extensions::add

* All places where the equivalent of greaterEqual occurs
* Clean up Strategies code/directory

Strategy::greaterEqual is only called from Strategy: >= Strategy.
Certainly if #tricks is lower anywhere, we should return false.
If if's higher anywhere (but not lower anywhere), it's true.
If it's equal everywhere, we have to look at the ranks too.

Presumably this sort of things shows up in all the way that we can
Strategies += Strategy, which probably is centered in
Strategies += Strategies as well.  It includes Extensions.

See if we can make two types of Result as well, and select on
whether the Winners matter.


Ranges
------
* Put in new directory
* See about virtual class configured at runtime


Ranks stored in tables
----------------------
* Write and read binary files with holdings to run vs. not
* Is it true that a minimal combination does not need non-minimal
  ones to solve?  If not, we would either solve the non-minimal
  ones, or look up the non-minimal one (probably better) and
  map the smaller number of distributions to the current case somehow


Overall rank of a Combination
-----------------------------
* Some best winners have choices ("top 2 of 3")
  - Leave all cards that may win at declarer's choice, even though
    that combination could simplify to several others
* All unused cards can be set to x in order to get the base case
* Could validate by limiting strategies to those that don't
  distinguish by x.  But how to detect?  Maybe once we know the
  plays that go with each strategy


Limited Plays considered
------------------------
* Shift something in Plays or Ranks such that the card number
  starts from 1, not 0, so is distinguishable in Nodes from void
  - I think this involves switching to fullFlag in Play.h, and then
  - samePartial will make different comparisons, but
  - then void == 0 and lowest == 1, otherwise we get aliasing

* Divide Ranks optimizations into those that always make sense, and
  those that only make sense when we don't care about winners.
* Can maybe parametrize Player by full/rank-only loop.  Only needed
  for North and South.
* Can maybe parametrize the Ranks optimizations in the same way.

Make a version of Ranks::setPlays with fewer optimizations:
- Don't have to save partner's cards of equal rank
- When equal rank, all depth combinations

Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

* Actual optimizations that are probably missing today
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).


Rank issues due to limited Plays considered
-------------------------------------------
*  8 /  1585, AQ8 / JT7 missing K9.  See spreadsheet.
*  9 /  4757, AQ8 / JT7.  See spreadsheet.
* 11 / 18752, AK8 / T765.  The result is 2S" (the 5) -- not needed.


Only symmetric strategies with complex voids?
---------------------------------------------
* 9: 14762 (KJ97 missing 5 cards) needs 68 distributions


Winning NS plays in semantic form
---------------------------------
* Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
* Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy


Applying constraints to defensive holdings
------------------------------------------
* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values


Bug / behavior?
---------------
Why doesn't it work in Combination to make complete copies of
everything?  It must be some stray pointers, but where?



Node index: print is irritating for the early plays.
Output for e.g. 11 cards all in one hand: More space.
Output also the rank in a rank listing of cards.
