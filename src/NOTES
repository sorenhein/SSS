2021-12-29
----------


2021-12-28
----------
Major next blocks:
1. Winners both-sided, hopefully they stay at length 1
2. Winners -> Winner, should save quite a lot of space
3. Ranks skips interesting plays
4. Rewrite CombTest
   - 
5. Continue partitioning of ace-high
   - Non-canonical (not "greater") -> the canonical version
   - Canonical may be completely non-minimal, so probably only
     has 1 minimal?
   - Canonical may be mixed, but then no reason to look at
     minimals?  Might as well solve it since we have to anyway
   - Canonical may be completely minimal

Both-sided winners: Where do these actually arise?
Strategy-level *= NO
+= NO
There is Slist::collapseOnVoid using Strategy::addComponentwise.
This occurs when the next trick has multiple strategies that 
actually differ in the surviving result.  I suppose we should
leave these apart.  Can we be sure that they're just different?
I guess we either do, or it doesn't matter...
If we skip this, could we then go back to the old compare in
Winner::compare?


2021-12-27
----------
It runs again now -- well, down to 11/159146 before it conks out.

WARNCRITICAL1     0
WARNCRITICAL2  5198
WARNRANGE1        0
WARNRANGE2       68     In getMinimalSpans may not need length equality
NONMIN         7579
KLUDGE            0
ODDLEN            0
SHIFT             0
ERROR             0

MINIMUM MATCH 37478
MIN MISMATCH   2491
WINNER MATCH1 32709
WIN MISMATCH1  8248
WIN MISMATCH2    15

Why are we interested in minimals in the first place? Because we just
want to solve these and then create the others as needed from these,
rather than solve these others.


Case A
------
5/59, AQ/J miss KT
#0 fin, 2N, Q is like 5/61, AQ/T miss KJ (too has #0, #1: 3N, 5N)
  Its #1 is like 5/75
#1 top, 4N, A is like 5/75, AT/J miss KQ (#0 top, 3N)

It's not right to say that 5/75 is THE minimal for 5/59.
5/59 #0 has a minimal in the form of 5/61 #0 and 5/61 #1,
which in turn becomes 5/61 #0 and 5/75 #0.
And directly 5/75 #0.
So effectively there are Strategy-level minimals 5/61 #0 and 5/75 #0.

It would be OK to have 5/61 + 5/75 which must match 5/59.

Case B
------
7/521, AQT/J missing Kxx:
#0 finesse, needs QJ so 7/537 AQ8/J missing KHH is a minimal.
#1 top, needs JT so it is effectively its own minimal.
In checking, we could take 7/521 #0 = 7/537 #0 plus 7/521 #1.
Then 7/521 #1 would be preferable to 7/537#1 to declarer.

This needs itself as a minimal in at least some regard.
It should work to have 7/521 + 7/537 which becames 7/521 again,
as 7/537 #1 is not as good for declarer.

Case C
------
AQ/K, can play as A maybe Q, or as K for sure.
In the former case the K is not needed.
So maybe we do need to keep track of each N *and* S winning card.
And we make a minimal from AQ/K using AQ, it should then be
AK/x and not stay at AQ/K.

5/35 AQ/K miss HH.
#0 K, K and maybe A.  Should become Ax/K. 5/51, K maybe A.
#1 top, A and maybe Q.  Should become(!) AK/x, 5/25, A maybe "K".

It should be OK to have 5/25 + 5/51.

Summary
-------
* Each Strategy get a minimal.
* Possibilities
  - All Strategy's are minimal to itself
    Nothing to check
  - All Strategy's are non-minimal
    Must add up to itself
  - Some are, some aren't
    The non-minimals must each be worse or equal to itself
* 



This makes Ranks::minimal different.  Even though K is > Q, it is
shifted down because it is below the "maximum" South winner of \infty.


Maybe Ranks gets a 

bool Ranks::minimal(
  const unsigned char absNumber, 
  CombReference& combRef) const
{
  // Returns true if combRef is set with a minimal != the Ranks.
}

Then each Strategy gets a minimal CombReference, h3 == 0 if not set.
When outputting Strategies, no Prod, but instead h3.

Strategies is non-minimal if *all* Strategy's are non-minimal, 
otherwise not.  Then each CombReference must be minimal, i.e. have
at least one minimal Strategy.



2021-12-26
----------
6/35, AKJ/Q missing HH: One strategy is to cash the ace and then
maybe the king.  Another is to cash the queen.  But this doesn't just
need 2S = Q, as the Q is lower than AK.  So I guess the Winner should
really be strictly the card with the lowest absolute number.

Is this actually a problem with play generation?
6/51: AK9/Q missing JT also has 3S = Q for d=1, whereas the ace
is enough.

6/89 AQJ/K miss HH: 
#0  #1
K   Q
K   A
K   Q
It is reasonable to keep both.
But in Combinations::getMinimals we should have one result per
Strategy and pass these to Ranks::getMinimals.
Then for #0 we'd get Axx/K missing QJ,
and  for #1 we'd get AQx/K missing JT.

So:
Combinations::getMinimals
Don't make one overall result for all strategies.
Make a list of result's for each strategy, pass to Ranks::getMinimals.




2021-12-24
----------
10/43051, QT6 / K9875 (for example), missing AJ
We get 3NS for d=0, 3N for d=3 which corresponds to leading to the Q.
We could also lead to the K and get 3N / 3NS.  Is the play left out
of Ranks?

Seems we crash out of 2 GB RAM during cards = 11?
- Some compiler flag?
- Cut Winners to Winner?

Maybe move all the tables from Ranks to cranks, then also the
methods canonicalTrinary and canonicalBoth.

Cleanup:
Comb counts from Combinations to class/struct?
Declarer: greater?
No Winners at all, once there's only ever 1?
Card: When use number, when absNumber?

5/17, 9/1340, 9/13649: Good test cases.

2021-12-05
----------
Ideas for ranks and no ranks.

Ranks
-----

No ranks
--------
- Non-canonicals are mapped the usual way
- Non-minimal canonicals are solved by minimals
- Minimals are solved normally (without winners)



2021-12-05
----------
Some additional optimizations with numbers, not ranks (xls)
See how many total plays are made now
See whether it would help to add some of the more marginal ideas

5/17, AK/Q miss xx.

        Start K         Start A
0       2N' + 2NS       2N'
1       2N' + 2S        2N + 2S
2       2N' + 2NS       2N'
MIN     2N' + 2NS       2N'

This is reduced to a minimal product of 2N' and then there is a
single minimal, 5/25 (AK/x missing xx).

        5/25            5/51
        AK/x            Ax/K
0       3N' -> 2N'      3NS -> 2NS
1       3N  -> 2N       3S  -> 2S
2       3N' -> 2N'      3NS -> 2NS
MIN     3N' -> 2N'      3NS -> 2NS

We need to find both minimals and to clean this up.  Maybe:

At the time when we start K-Q or KxQ, we have to declare whether the
double winner is going to be 2N' or 2S.  Up to now we've kept the
optionality in the Strategies, but that's probably wrong.  Instead

d  K-Q(Q) K-Q(K) KHQ(Q) KHQ(K) A-Q(Q) A-Q(A) AHQ(Q) AHQ(A)
0                2NS    2N'                  2N'S   2N'
1                2S     2N'                  2S     2N
2  2NS    2N'                  2N'S   2N'
                               (bad)

There are two strategies for each set of three first cards.
E-W cause multiplications.

d  start with K            start with A
0  2NS  2NS  2N'  2N'      2N'S  2N'
1  2S   2S   2N'  2N'      2S    2N
2  2NS  2N'  2NS  2N'      2N'   2N'
st #0   #1   #2   #3       #4    #5
                  (bad)    (bad)
mi 2NS  2N'S 2N'S                2N'

#3 loses to #5
#4 loses to #1

#0 is definitely valid: "Cash" the Q
#5 is also valid      : Cash the A
The question is whether #1 and #2 are valid.
I think we can't draw conclusions just from the worse products.
They're also not dominated by anything else.
The question is whether declarer can lead the K and then decide
whether or not the Q is higher depending on East's play.  I guess not.

If so, we have to find a way to restrict that.




Once we have the two strategies, don't combine their winners.
For each plus term, multiply out against its own strategy and simplify.
Effectively, when starting with the ace, why want to win the Q?

        Start K         Start A
0       2NS             2N'
1       2S              2N
2       2NS             2N'
MIN     2NS             2N'

Then each of these leads to a minimal.  

Another problem: 9/377 just fails, AKQ/JT9, quite early on.  Why?





2021-12-04

9/1340 has 1 strategy using 2S' which should be sth higher.
We can determine from the minimals that there should not be a strategy
with a winner < 4.

I suppose we could pretend (centry.winRankLow) that we really only
use a higher rank, but leave Strategies intact.  Then we'd get a
Strategies and Winners mismatch, which seems reasonable.

Sometimes there are indeed strategies to be eliminated, I think.
Here we'd need to go by the size of the Strategies and its minimals.
The minimals should all have the same number.  If we already have
that number, do as above.  If we have fewer, wTF?  If we have more,
try to reduce and check that we get the right number, otherwise WTF?

2021-12-03

Output now cleanish again.

29417   MINIMUM MATCH
    0   MINIMUM MISMATCH

25428   WINNER MATCH 1
 1314   WINNER MATCH 2

  801   WINNER MISMATCH 1
  217                   2
   39                   3
    1                   1
    1                   1

   26   WARNRANGE

- Look at winner mismatches
- Minimum matches: Also all ranks, not just tricks
- Find a way to see whether we're missing minimals (AK and Q but not QJ)

- strategies: fix in Combinations
- Then CombTest is purely passive



2021-12-02

9/13649, KQT / 987 missing AJ6
Shows 2N,2S" (T or 7)
max rank 4, low winner 2

minimals
9/13675, KQT / 876 missing AJ9
shows 3N (T)
max rank 5, low winner 3

9/13735, KQ7 / T96 missing AJ8
shows 5N' (Q)
max rank 5, low winner 5

Fails because the two minima don't have the same difference
between max rank and low winner.

I think the concrete problem is that with KT missing AJ in front,
if West plays the ace, North will play the K and win with the T.
But at the moment the plays are always from the top within a rank.

We don't even have a way to do this differently.


2021-10-25

CombTest,checkReductions: Should now not need reduceByTricks.
Just use strategies.


Was 22,797 OK, 5,324 bad
Is  25,210 OK, 2,911 bad
Is  28,099 OK,    22 bad

11/133100, KJ7 / 98 miss AQT8xx and 133106, KJ7 / 95    2
-> 133108, KJ7 / 94

11/133142, KJ6 / 95 miss AQT874                         1
-> 133144, KJ6 / 94

11/133208, KJ8 / 76, 133214, KJ8 / 75                   5       plays??
   133216, KJ8 / 74, 133232, KJ8 / 65
   133234, KJ8 / 64
-> 133240, KJ8 / 54

11/133292, KJ5 / 87, 133296, KJ4 / 87                   4
   133304, KJ6 / 85, 133314, KJ4 / 86
-> 133318, KJ5 / 84

11/136124, KT8 / 76, 133130, KT8 / 75                   5       plays??
   136132, KT8 / 74, 136148, KT8 / 65
   136150, KT8 / 64
-> 136156, KT8 / 54

11/162368, QT8 / 65, 162374, QT8 / 75                   5       plays??
   162376, QT8 / 74, 162392, QT8 / 65
   162394, QT8 / 64
-> 162400, QT8 / 54


 
2. equalByMethod
   Divide completely by size
   assert size(v1) >= size(v2)?

3. Does group-trick check even work?

4. Sum of min ranks == parent rank?

5. merge...


Open issues 2021-09-26
----------------------
Look at speeding up Slist::equalByMethod.

3. Winners of each minimal should be the winner it was made from.
   Maybe once it has been expanded, it is easier to compare.

4. Reduce each non-minimal strategy.
   Scale up each of the minimals, including rank maps.
   Each should agree on the tricks.

5. bool Strategy::mergeComplete(const Strategy&)
   Should have same tricks throughout
   Ranks should all be the same, except that one strategy can
   consistently have one constant rank (say 4N) and the other can
   consistently have another constant rank (say 4S), and this would
   merge and return true into 4N,4S
   If #1 is true, then this can be done directly without expansion.

   If there are several minimals, 
   a. They should scale up in a way that lets them merge one by one(?)
   b. That merge should be the original strategy(?)

6. For void starting with 10-13 cards (assuming we solve up to 13
   cards), it's always OK to symmetrize, as we can never get there
   from non-void combinations.  We do this:
   a. If we get above [100] strategies, we start over and only
      look up symmetrized strategies (so 6-8 and 8-6 are done together
      and symmetrized against each other).  Multiply strategy by
      strategy, I think, and don't do a complete cross
   b. In the end, if we are above [16] strategies, we symmetrize
   c. If we know from lookup that something must be symmetric

7. Go from only batch to solving a single distribution from scratch
   a. Basic idea is to make a list of the nodes you'll need
   b. Then make these recursively before you solve this node
   c. A lot of flags are the same, i.e. ranks or not, optimizations
      turned on or not, debugging/checks on/off
   d. Could switch to the minimal one (or one of them) and only
      solve this


1091 combinations generate a "check all minimals" error.
This should hopefully be fixed once the ranks are correct.

A histogram of #strategies shows that we also get large numbers
when South has a single card, e.g. 11/132887, KJ95 / 7 missing AQT864.
Maybe it's OK to limit next strategies to symmetric ones, too,
when South becomes void and there are a lot of next strategies.

Symmetrize 11 / 132902, KJ96 / void: From 132,902 to 166 strategies.
Less than half the square root.


Reduction
---------
* 9: 14762 (KJ97 missing 5 cards) needs 68 distributions

-d
  - Optimize the code for minimal()
  - Also optimize for Strategies == even though it doesn't matter
    - Start at ==, only do upper triangle of matrix


Checks
------
* Node optimization (on/off)
* Strategies *= optimization (on/off)

Check speed and identity of results


Ranks stored in tables
----------------------
* Write and read binary files with holdings to run vs. not
* Is it true that a minimal combination does not need non-minimal
  ones to solve?  If not, we would either solve the non-minimal
  ones, or look up the non-minimal one (probably better) and
  map the smaller number of distributions to the current case somehow


Limited Plays considered
------------------------
* Shift something in Plays or Ranks such that the card number
  starts from 1, not 0, so is distinguishable in Nodes from void
  - I think this involves switching to fullFlag in Play.h, and then
  - samePartial will make different comparisons, but
  - then void == 0 and lowest == 1, otherwise we get aliasing

* Divide Ranks optimizations into those that always make sense, and
  those that only make sense when we don't care about winners.
* Can maybe parametrize Player by full/rank-only loop.  Only needed
  for North and South.
* Can maybe parametrize the Ranks optimizations in the same way.

Make a version of Ranks::setPlays with fewer optimizations:
- Don't have to save partner's cards of equal rank
- When equal rank, all depth combinations

Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

* Actual optimizations that are probably missing today
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).


Rank issues due to limited Plays considered
-------------------------------------------
*  8 /  1585, AQ8 / JT7 missing K9.  See spreadsheet.
*  9 /  4757, AQ8 / JT7.  See spreadsheet.
* 11 / 18752, AK8 / T765.  The result is 2S" (the 5) -- not needed.


Winning NS plays in semantic form
---------------------------------
* Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
* Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy


Applying constraints to defensive holdings
------------------------------------------
* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values


Bug / behavior?
---------------
Why doesn't it work in Combination to make complete copies of
everything?  It must be some stray pointers, but where?

Mixed strategies
----------------
In the end we may not have to do so much LP.  EW must find play for
each distribution that work against all NS strategies.  EW get into
trouble when they need to vary their play depending on what NS do.
So we keep track of all plays that work in various situations, and we
take the intersection which is often not empty.

I'm hoping this will also give rise to the mandatory falsecards that
protect not this holding, but some other holding.

Perhaps represent all the NS strategies as some kind of tree with the
branching points that they will actually make use of.

In the end there will be the combinations with mixed potential.  But
I think we can do all the above independent of external constraints.
So we can actually tell in the abstract which combinations have the
potential for mixed strategies, even without knowing the constraints?!


TODO
----
Not all features of Control.cpp are implemented yet

No / limited endl

In Card, can we think of a way to avoid depth?  Probably not, 
as it is useful for the output.  Maybe avoid number then? Or name?
