In Player, move to rankInfo and delete fullCount and names.
remainders can actually be cards together with the number of the
card played.  If the later winner to be translated has a number >=
the card played, then later#+1, otherwise just later#.

best can use rankInfo[rank1].ptr and partner.rankInfo[rank2].ptr
as the two cards for the winner.

Don't keep resizing best.  Keep it at maximum size.  When we're
debugging, we may clear each winner perhaps.

In Ranks, log plays into a struct that is passed directly to Plays.

Divide Ranks optimizations into those that always make sense, and
those that only make sense when we don't care about winners.

Can maybe parametrize Player by full/rank-only loop.  Only needed
for North and South.

Can maybe parametrize the Ranks optimizations in the same way.

Streamline the Player post-processing into a single call.

Streamline Player variables and name them temporary loop variables.

Break up struct.h, make a Survivors.h (class? protect data?)



1. Why does the rank stuff take 10 seconds now?



March 2021
----------
KQ / J9 missing AT: EW can make NS choose between K (duck) and QJ (win).
QJ / K9: Same, here it's Q and KJ.
KJ / Q9: K or JQ.
It seems true that not just the K should be the winner in the end.
In a way, the problem is that that we could simplify to KQ / xx or
to Kx / Qx. In fact, here probably it's an EW choice between K and Q.
And these should definitely both survive.

So in these three cases more generally, the first trick can go
N1 wins, then no more tricks for NS.
It can also go
N1 loses, then NS just have a choice between N2 and S1.
N1 * (N2 + S1) = N2 + N1*S1.
This means we can either view it as KQ / xx or as Kx / Qx.

2021-03-21
----------
Make a version of Ranks::setPlays with fewer optimizations:
- Don't have to save partner's cards of equal rank
- When equal rank, all depth combinations

Issues
1. 10/4025, AK76 / QT9 missing J85:
   a. 7 5 T 8 has T as winner!  (Play 4)
   b. T - A 5 segfaults, probably because it's a rotation

2. Drilling down from this, if the first trick goes 7 - T J,
   it leaves us with 7/128 so AK9 / QJ missing T8.  Because of 
   optimizations in Ranks.cpp, we don't get to see all the combinations
   of ranks that can happen.  So if it goes Q - 9 8, we have
   SQ * (NA + SJ) = NA*SQ + SJ = NA*SQ,
   as we'd always prefer the choice between NA and SQ to a forced SJ.
   This of course assumes that we win with the SQ and not the SJ in 
   the first trick.

3. It could also have gone e.g. Q T A 8 which is a choice NA + SQ.
   This is better (more flexible) for NS than just SQ which is the
   current outcome when d = 2.

4. It could also go A - Q 8, so
   (NA + SQ) * (NK + SJ) = NK + SJ + NK*SQ + NA*SJ = NK + SJ, 
   as NK*SQ is worse for NS than just NK.

5. But it could also go A - J 8, so
   (NA + SJ) * (NK + SQ) = NK + SJ + NA*SQ + NK*SJ = NK + SJ + NA*SQ,
   which makes sense.  We can reduce to AKx / xx, xx / AKx or Axx / Kx.

6. Or it could go K - Q 8(?), so
   (NK + SQ) * (NA + SJ) = NK + SJ + NA*SQ + NK*SJ = #5

7. Or it could go K - J 8, so
   (NK + SJ) * (NA + SQ) = NK + SJ + NA*SJ + NK*SQ = #4
   
   So how do we make sure to get the second and not the first result?

8. Another example: AKx / JT missing Qxx.
   J x x: NK*SJ.
   J Q A: NA * (NK * ST) = NK*ST.

   T x x: NK*ST.
   T Q A: NA * (NK * SJ) = NK*SJ.

   It looks as if EW can force NK*ST no matter how South starts.
   I suppose that's as it should be.  So we can always start with the
   highest rank -- it doesn't matter.

9. Problem #1 is that Ranks optimizes away plays that are relevant
   for ranks in this case.  So Ranks could have a full-play mode, needed
   to calculate the tables of relevant ranks (stored in files).  And
   a reduced-play mode as now.

10.Problem #2 is when NS have a shared winner in the current trick.
   It's not clear then which depths were played. Can we just choose
   the highest from one side and the lowest from the other? Or do we
   need to consider two such combinations? Here it would work.
   

Still need to look at += at vector level and choose among equal-trick
vectors the one with the best rank profile (can we need both?).


Rank tracking
* += is more or less unchanged, but if two vectors are equal,
  and NS can pick one, then hopefully one dominates the other
  (or they are equal) in terms of ranks.  Otherwise assert
* Tvector: add method lowestWinner()
* Tvectors: ditto
* Somehow map to the holding without lower cards than this mattering

   

Summary of speed-up considerations
----------------------------------

Rank equivalence

* 9: 14762 (KJ97 missing 5 cards) needs 68 distributions with the
  normal analysis, and still needs 58 distributions the new way
* When we lead the 7, the defenders with 4/5 cards can probably pick
  constant plays that leave declarer no recourse
* With 3 cards, the defenders can choose to yield "KJ9" or "KJT",
  no matter what the lead is (as long as they're not forced to
  play the Q or A, which again leads to no declarer choice)
* So in a sense the small cards x, 8 and T don't matter!
* We have to recognize this somehow, as strategies will merge

Similarity

* Treat K A x the same as J Q x?  They end up in the same next
  combination, with the cards from the same side.  So then merge
  using |=, not *= ?
  - Probably not a good idea

Improve *= efficiency

* If merge doesn't change the vector, no need to compare
* Short strategy, e.g. with 3 distributions
  - Somehow split into overlapping/in-band and other/out-of-band
    distributions
  - Is there a way to tell in some cases that something will be
    a surviving strategy?
* In the merged strategy, the two non-overlaps' origins in the original
  strategies are stored
  - Before merging, we study the non-overlaps
  - How many really distinct ones are there?
  - If not a lot, consider a complete cross-table (matrix) of
    relationships (dominates, is dominated by, is different)
  - Also three lists for each one of dominates, is dominated by etc.
  - Can index by the weight of the non-overlapping part?
* In a new merge, the non-overlaps are just copied over
  - We can tell by looking at other merges whether we have a chance
    or dominating or being dominated by
* The overlaps do have to be made properly
  - Can stop if the two overlaps are already "contradictory"
  - Even if we don't stop, some theories can be eliminated
  - Their weight is a first indication of possible domination
  - Then drill down into pieces
* In a merge, start looking for identities?  (Empirical question)
* Then look for being dominated?
  - The accepted strategy has a profile across buckets, and we can
    make statistics
  - We pick our own strongest bucket first and try to beat other
    stored strategies 
- Initially just a flat list
- organize(ordered list of distributions in groups)
  makes partial sums for the groups
  also makes a kind of hash for equality checking (group sums)
- partials()
  returns ordered list of partial sums for groups
- prioritize(ordered list of groups)
  sets the order of comparison.  Top group is the one where the vector
  is relatively highest.  So if you want to beat this vector, you
  compare first to the toughest comparison in order to lose quickly.
  If you want to lose to this vector, you first try to lose to its
  weakest group in order to fail quickly
- == first uses the hash and then individually
- > uses the prioritized groups and then individually
* Organization
  - Histogram of vector weights, each bucket containing a list
* In +=
  - First check for equality
    If it works, we're done
  - Then check whether we're dominated by something
    If yes, we're done
  - Add ourselves to the histogram
  - Then check whether we dominate something
    If yes, remove it
* In *=
  - Start with the largest times one vector
  - organize() each vector with a list, maybe co-prime "hash"
  - Figure out the partials
  - Sort them
  - prioritize() each vector
  - Then go through the other second vectors
  - After ~ 20% of the second vectors, re-sort and re-prioritize()
* Ordering of strategies in *= sequence?!
  - Maybe do the two "halves" and then merge to break symmetry?!
*

Speed-ups:

- Tvectors::reinstate(const Tvector& constants)
  Puts the constant distributions back.
  They must not already be there.
  Adjust weights too.

Play eliminations
-----------------

Play eliminations, based on KJ975 missing AQT8xx, so
whenever partner is void:

* In fourth hand where LHO is void, always win cheaply or play lowest
  if you can't win
* In second hand when RHO will show up as void, ditto

Also when we have AQT8 / 64 missing KJ9753, we know that 64 are lower
and shorter than all North cards, so their ranks can't matter.
- Can simplify manually: AQT8 / 64 missing KJ9753.  We can never
  take a rank trick < 8. |S| <= |N|.  Max S <= Max N.  But this only
  gets some of the tough ones.

Optimization in Ranks:
- With AQ / - missing KJ, on Ace never drop King (partner will show
  out and the lead was the top card)
- With KJ / - missing AQ, on K never play Q (partner HAS shown out,
  so always win trick)
- Maybe in 4th hand when NS are down to <= 1 card after this trick,
  KJ with AQxx outstanding for example (6/548).

How do we get the complexity down again?
- The *= can be improved to do partial comparisons before full ones.



- Winning ranks for NS
- Winning plays/strategies such as "cash ace"
  - Sometimes NS have several ways to reach its optimum; keep them all
- Noting the inequalities on EW plays that are needed to stabilize
  an NS strategy

------

* Distribution::limit, using a struct that Control returns
  - We will fail for now on some HCP values

